<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>DOOM-like Web Raycaster</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #000;
        color: #eee;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
          Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji",
          "Segoe UI Emoji";
      }
      #hud {
        position: absolute;
        top: 12px;
        left: 12px;
        right: 12px;
        display: flex;
        gap: 12px;
        align-items: center;
        pointer-events: none;
      }
      .chip {
        background: rgba(0, 0, 0, 0.45);
        border: 1px solid rgba(255, 255, 255, 0.12);
        padding: 8px 12px;
        border-radius: 999px;
        font-size: 12px;
        backdrop-filter: blur(6px);
      }
      #help {
        position: absolute;
        bottom: 12px;
        left: 12px;
        right: 12px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      #help .chip {
        pointer-events: auto;
      }
      #container {
        position: fixed;
        top: 50%;
        left: 50%;
        width: 800px;
        height: 600px;
        transform: translate(-50%, -50%);
        border: 2px solid #fff;
        background: #000;
        overflow: hidden;
      }
      #game {
        width: 100%;
        height: 100%;
        display: block;
      }
      #overlay {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        background: radial-gradient(
          ellipse at center,
          rgba(0, 0, 0, 0.35),
          rgba(0, 0, 0, 0.8)
        );
        color: #fff;
        font-weight: 600;
        letter-spacing: 0.3px;
        text-align: center;
      }
      #overlay.hidden {
        display: none;
      }
      #overlay .card {
        max-width: 640px;
        padding: 24px;
        border-radius: 16px;
        background: rgba(0, 0, 0, 0.5);
        border: 1px solid rgba(255, 255, 255, 0.12);
        backdrop-filter: blur(8px);
      }
      #overlay button {
        pointer-events: auto;
        margin-top: 12px;
        padding: 10px 16px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: #1e1e1e;
        color: #fff;
        font-weight: 600;
        cursor: pointer;
      }
      #minimap {
        position: absolute;
        top: 12px;
        right: 12px;
        width: 160px;
        height: 160px;
        border-radius: 12px;
        overflow: hidden;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.35);
      }
      #weaponHud {
        position: absolute;
        bottom: 0;
        left: 50%;
        transform: translateX(-50%);
        width: 320px;
        height: 100px;
        pointer-events: none;
      }
      canvas {
        image-rendering: pixelated;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <canvas id="game" width="800" height="600"></canvas>
      <canvas id="weaponHud" width="320" height="100"></canvas>

      <div id="hud">
        <div class="chip" id="fps">FPS: --</div>
        <div class="chip" id="health">Vida: 100</div>
        <div class="chip">
          WASD para moverte · Mouse para mirar · Shift para correr · Esc para
          pausar
        </div>
      </div>
      <canvas id="minimap" width="160" height="160"></canvas>

      <div id="help">
        <div class="chip">
          Consejo: si el mouse no gira, haz clic en "Iniciar" para activar Pointer
          Lock.
        </div>
      </div>

      <div id="overlay">
        <div class="card">
          <h2>DOOM‑like Web (Raycaster)</h2>
          <p>
            Pequeño clon estilo DOOM/Wolf3D con raycasting en Canvas 2D. No usa
            assets de DOOM: todo es generado.
          </p>
          <p>
            Controles: <strong>WASD</strong> moverse ·
            <strong>Mouse</strong> mirar · <strong>Shift</strong> correr ·
            <strong>R</strong> reiniciar · <strong>Esc</strong> liberar puntero.
          </p>
            <label>
              Mapa:
              <select id="mapSelect"></select>
            </label>
            <label>
              FOV: <span id="fovValue">90</span>°
              <input id="fovRange" type="range" min="60" max="120" value="90" />
            </label>
            <button id="startBtn">Iniciar</button>
        </div>
      </div>
    </div>

    <script>
      // ===== Config =====
      let FOV = Math.PI / 2; // 90° campo de visión (Quake-like)
      let baseFOV = FOV;
      const MOVE_SPEED = 3.2;
      const RUN_MULT = 1.8;
      const ROT_SPEED_MOUSE = 0.0022; // yaw
      const PITCH_SPEED_MOUSE = 0.0016; // pitch
      const PITCH_LIMIT = Math.PI / 6; // ~30°
      const HEAD_BOB_FREQ = 7.5; // Hz aprox
      const HEAD_BOB_AMP = 6; // píxeles
      const PLAYER_MAX_HEALTH = 100;

      // Colores de respaldo si no hay textura
      const WALL_COLORS = [
        "#000000",
        "#c0392b",
        "#27ae60",
        "#2980b9",
        "#8e44ad",
        "#f39c12",
      ];

        // Mapa 2D (grid de celdas). 0 = vacío; >0 = pared (tipo/color)
        let MAP_W = 0,
          MAP_H = 0;
        let MAP = [];
        let spawn = { x: 0, y: 0, dir: 0 };

      const TEX_SIZE = 64;
      const wallTextures = []; // por id de celda (>0)
      const weaponTexture = { img: null };

      function makeChecker(a, b) {
        const c = document.createElement("canvas");
        c.width = c.height = TEX_SIZE;
        const g = c.getContext("2d");
        for (let y = 0; y < TEX_SIZE; y++)
          for (let x = 0; x < TEX_SIZE; x++) {
            const on = (((x >> 3) + (y >> 3)) & 1) === 0;
            g.fillStyle = on ? a : b;
            g.fillRect(x, y, 1, 1);
          }
        return c;
      }

      function at(x, y) {
        if (x < 0 || y < 0 || x >= MAP_W || y >= MAP_H) return 1; // borde como pared
        return MAP[y * MAP_W + x];
      }

      // ===== Canvas setup =====
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const minimap = document.getElementById("minimap");
      const mctx = minimap.getContext("2d");

      function resize() {
        canvas.width = 800;
        canvas.height = 600;
      }
      window.addEventListener("resize", resize);
      resize();

      // ===== Player =====
      const player = {
        x: 0,
        y: 0,
        dir: 0, // ángulo mirando
        velX: 0,
        velY: 0,
        health: PLAYER_MAX_HEALTH,
      };
      // ===== Weapons =====
      const weapons = [
        {
          name: "Puños",
          damage: 5,
          range: 1,
          color: "#999",
          fireDelay: 0.5,
          bulletSpeed: 15,
          clipSize: 1,
          loaded: 1,
          ammo: 0,
          reloadTime: 0,
          noAmmo: true,
        },
        {
          name: "Pistola",
          damage: 10,
          range: 6,
          color: "#ccc",
          fireDelay: 0.3,
          bulletSpeed: 25,
          clipSize: 8,
          loaded: 8,
          ammo: 24,
          reloadTime: 1.2,
        },
        {
          name: "Escopeta",
          damage: 25,
          range: 5,
          color: "#b5651d",
          fireDelay: 1.0,
          bulletSpeed: 20,
          clipSize: 2,
          loaded: 2,
          ammo: 18,
          reloadTime: 1.5,
        },
        {
          name: "Sniper",
          damage: 50,
          range: 20,
          color: "#3af",
          fireDelay: 1.5,
          bulletSpeed: 40,
          clipSize: 1,
          loaded: 1,
          ammo: 4,
          reloadTime: 2.0,
          zoomFOV: Math.PI / 8,
        },
      ];
      let currentWeapon = 0;
      let zoomed = false;
      let weaponCooldown = 0;
      let bullets = [];
      let enemies = [];
      let shooting = false;
      let reloading = false;
      let reloadTimer = 0;
      let weaponAnim = 0;

      function equipWeapon(i) {
        currentWeapon = i;
        zoomed = false;
        FOV = baseFOV;
        reloading = false;
        weaponCooldown = 0;
        weaponAnim = 0;
        shooting = false;
      }

      const weaponCanvas = document.getElementById("weaponHud");
      const wctx = weaponCanvas.getContext("2d");

      function drawWeaponHUD() {
        const w = weaponCanvas.width,
          h = weaponCanvas.height;
        wctx.clearRect(0, 0, w, h);
        wctx.fillStyle = "rgba(0,0,0,0.5)";
        wctx.fillRect(0, 0, w, h);
        const weapon = weapons[currentWeapon];
        const offset = Math.sin(weaponAnim * Math.PI) * 20;
        wctx.fillStyle = weapon.color;
        wctx.fillRect(w / 2 - 40, h - 80 + offset, 80, 80);
        wctx.fillStyle = "#fff";
        wctx.textAlign = "center";
        wctx.font = "14px sans-serif";
        wctx.fillText(weapon.name, w / 2, 20);
        if (!weapon.noAmmo)
          wctx.fillText(`${weapon.loaded}/${weapon.ammo}`, w / 2, 40);
      }

      drawWeaponHUD();

      function startReload() {
        const w = weapons[currentWeapon];
        if (w.noAmmo || reloading || w.loaded >= w.clipSize || w.ammo <= 0)
          return;
        reloading = true;
        reloadTimer = w.reloadTime;
        weaponAnim = 1;
      }

      function shoot() {
        const w = weapons[currentWeapon];
        if (!w.noAmmo) {
          if (w.loaded <= 0) {
            startReload();
            return;
          }
          w.loaded--;
        }
        weaponCooldown = w.fireDelay;
        weaponAnim = 1;
        bullets.push({
          x: player.x,
          y: player.y,
          dir: player.dir,
          speed: w.bulletSpeed,
          damage: w.damage,
          range: w.range,
          traveled: 0,
        });
      }

      function updateBullets(dt) {
        for (let i = bullets.length - 1; i >= 0; i--) {
          const b = bullets[i];
          const nx = b.x + Math.cos(b.dir) * b.speed * dt;
          const ny = b.y + Math.sin(b.dir) * b.speed * dt;
          const dist = Math.hypot(nx - b.x, ny - b.y);
          b.traveled += dist;
          if (at(Math.floor(nx), Math.floor(ny)) > 0 || b.traveled > b.range) {
            bullets.splice(i, 1);
            continue;
          }
          b.x = nx;
          b.y = ny;
          for (const e of enemies) {
            if (Math.hypot(e.x - b.x, e.y - b.y) < 0.3) {
              e.health -= b.damage;
              bullets.splice(i, 1);
              break;
            }
          }
        }
      }

      function updateEnemies(dt) {
        for (const e of enemies) {
          const dx = player.x - e.x;
          const dy = player.y - e.y;
          const dist = Math.hypot(dx, dy);
          if (dist < 0.5) {
            player.health = Math.max(0, player.health - 20 * dt);
          } else if (dist < 6) {
            const nx = e.x + (dx / dist) * e.speed * dt;
            const ny = e.y + (dy / dist) * e.speed * dt;
            tryMoveEntity(e, nx, ny);
          }
        }
        enemies = enemies.filter((e) => e.health > 0);
      }

      // ===== Input =====
      const keys = new Set();
      window.addEventListener("keydown", (e) => {
        keys.add(e.code);
        if (e.code === "KeyR") startReload();
        if (e.code === "Digit0") equipWeapon(0);
        if (e.code === "Digit1") equipWeapon(1);
        if (e.code === "Digit2") equipWeapon(2);
        if (e.code === "Digit3") equipWeapon(3);
      });
      window.addEventListener("keyup", (e) => keys.delete(e.code));

      window.addEventListener("wheel", (e) => {
        equipWeapon(
          (currentWeapon + (e.deltaY > 0 ? 1 : -1) + weapons.length) %
            weapons.length
        );
      });

      // Pointer lock para mirar con mouse
      const overlay = document.getElementById("overlay");
      const startBtn = document.getElementById("startBtn");
      const fovRange = document.getElementById("fovRange");
      const fovValue = document.getElementById("fovValue");
      const mapSelect = document.getElementById("mapSelect");

      async function loadMapList() {
        try {
          const res = await fetch("maps/index.json");
          const data = await res.json();
          data.maps.forEach((m) => {
            const opt = document.createElement("option");
            opt.value = m.file;
            opt.textContent = m.name;
            mapSelect.appendChild(opt);
          });
        } catch (e) {
          console.error("No se pudieron cargar los mapas", e);
        }
      }
      loadMapList();

      startBtn.addEventListener("click", async () => {
        try {
          const res = await fetch(`maps/${mapSelect.value}`);
          const data = await res.json();
          MAP_W = data.width;
          MAP_H = data.height;
          MAP = data.grid;
          spawn = data.player;
          resetPlayer();
          spawnEnemies();
          canvas.requestPointerLock();
        } catch (e) {
          console.error("Error al cargar el mapa", e);
        }
      });
      document.addEventListener("pointerlockchange", () => {
        const locked = document.pointerLockElement === canvas;
        overlay.classList.toggle("hidden", locked);
      });
      fovRange.addEventListener("input", () => {
        baseFOV = (fovRange.value * Math.PI) / 180;
        if (!zoomed) FOV = baseFOV;
        fovValue.textContent = fovRange.value;
      });
      window.addEventListener("mousedown", (e) => {
        if (e.button === 0) shooting = true;
        if (currentWeapon === 3 && e.button === 2) {
          zoomed = true;
          FOV = weapons[3].zoomFOV;
        }
      });
      window.addEventListener("mouseup", (e) => {
        if (e.button === 0) shooting = false;
        if (e.button === 2 && zoomed) {
          zoomed = false;
          FOV = baseFOV;
        }
      });
      window.addEventListener("contextmenu", (e) => e.preventDefault());
      window.addEventListener("mousemove", (e) => {
        if (document.pointerLockElement === canvas) {
          player.dir += e.movementX * ROT_SPEED_MOUSE;
        }
      });

      function resetPlayer() {
        player.x = spawn.x;
        player.y = spawn.y;
        player.dir = spawn.dir;
        player.health = PLAYER_MAX_HEALTH;
      }

      function spawnEnemies() {
        enemies = [];
        const count = Math.max(5, Math.floor((MAP_W * MAP_H) / 64));
        let tries = 0;
        while (enemies.length < count && tries < count * 20) {
          const x = Math.random() * MAP_W;
          const y = Math.random() * MAP_H;
          if (
            at(Math.floor(x), Math.floor(y)) === 0 &&
            Math.hypot(x - spawn.x, y - spawn.y) > 3
          ) {
            enemies.push({ x, y, health: 30, speed: 1.2 });
          }
          tries++;
        }
      }

      // ===== Raycasting =====
      function castAndDraw() {
        if (!MAP_W || !MAP_H) return;
        const w = canvas.width,
          h = canvas.height;

        // cielo y piso
        const skyGrad = ctx.createLinearGradient(0, 0, 0, h / 2);
        skyGrad.addColorStop(0, "#1a1f2e");
        skyGrad.addColorStop(1, "#2b3a55");
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, w, h / 2);
        const floorGrad = ctx.createLinearGradient(0, h / 2, 0, h);
        floorGrad.addColorStop(0, "#2b2b2b");
        floorGrad.addColorStop(1, "#0e0e0e");
        ctx.fillStyle = floorGrad;
        ctx.fillRect(0, h / 2, w, h / 2);

        // parámetros de cámara
        const dirX = Math.cos(player.dir),
          dirY = Math.sin(player.dir);
        const planeMag = Math.tan(FOV / 2);
        const planeX = -dirY * planeMag;
        const planeY = dirX * planeMag;

        // ray per column
        for (let x = 0; x < w; x++) {
          const cameraX = (2 * x) / w - 1; // -1..1
          const rayDirX = dirX + planeX * cameraX;
          const rayDirY = dirY + planeY * cameraX;

          // mapa grid
          let mapX = Math.floor(player.x);
          let mapY = Math.floor(player.y);

          // longitud de rayo a la próxima x/y
          const deltaDistX = Math.abs(1 / (rayDirX || 1e-6));
          const deltaDistY = Math.abs(1 / (rayDirY || 1e-6));

          let stepX, stepY;
          let sideDistX, sideDistY;

          if (rayDirX < 0) {
            stepX = -1;
            sideDistX = (player.x - mapX) * deltaDistX;
          } else {
            stepX = 1;
            sideDistX = (mapX + 1.0 - player.x) * deltaDistX;
          }
          if (rayDirY < 0) {
            stepY = -1;
            sideDistY = (player.y - mapY) * deltaDistY;
          } else {
            stepY = 1;
            sideDistY = (mapY + 1.0 - player.y) * deltaDistY;
          }

          let hit = 0,
            side = 0,
            texId = 1;
          // DDA
          for (let i = 0; i < 64; i++) {
            if (sideDistX < sideDistY) {
              sideDistX += deltaDistX;
              mapX += stepX;
              side = 0;
            } else {
              sideDistY += deltaDistY;
              mapY += stepY;
              side = 1;
            }
            hit = at(mapX, mapY);
            if (hit > 0) {
              texId = hit;
              break;
            }
          }

          // distancia perpendicular para evitar fisheye
          let perpWallDist;
          if (side === 0)
            perpWallDist =
              (mapX - player.x + (1 - stepX) / 2) / (rayDirX || 1e-6);
          else
            perpWallDist =
              (mapY - player.y + (1 - stepY) / 2) / (rayDirY || 1e-6);

          // altura de la línea
          const lineHeight = Math.max(1, Math.floor(h / perpWallDist));
          let drawStart = -lineHeight / 2 + h / 2;
          if (drawStart < 0) drawStart = 0;
          let drawEnd = lineHeight / 2 + h / 2;
          if (drawEnd >= h) drawEnd = h - 1;

          // color y sombreado
          const base = WALL_COLORS[texId % WALL_COLORS.length] || "#aaa";
          // convertir hex a rgb
          const rgb = hexToRgb(base);
          const shade = 1 / (1 + perpWallDist * perpWallDist * 0.15);
          const dim = side ? 0.85 : 1.0; // lado Y un poco más oscuro
          const r = Math.min(255, Math.floor(rgb.r * shade * dim));
          const g = Math.min(255, Math.floor(rgb.g * shade * dim));
          const b = Math.min(255, Math.floor(rgb.b * shade * dim));
          ctx.fillStyle = `rgb(${r},${g},${b})`;
          ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);

          // pseudo-textura: franjas sutiles
          if (((mapX + mapY) & 1) === 0 && x % 3 === 0) {
            ctx.fillStyle = `rgba(0,0,0,0.15)`;
            ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);
          }
        }
        drawEnemies3D();
      }

      function drawEnemies3D() {
        for (const e of enemies) {
          const dx = e.x - player.x;
          const dy = e.y - player.y;
          const dist = Math.hypot(dx, dy);
          let angle = Math.atan2(dy, dx) - player.dir;
          while (angle > Math.PI) angle -= Math.PI * 2;
          while (angle < -Math.PI) angle += Math.PI * 2;
          const fov2 = FOV / 2;
          if (Math.abs(angle) > fov2) continue;
          const size = Math.min(canvas.height, (canvas.height / dist) * 0.8);
          const sx = canvas.width / 2 + Math.tan(angle) * (canvas.width / 2);
          ctx.fillStyle = "red";
          ctx.fillRect(sx - size / 2, canvas.height / 2 - size / 2, size, size);
        }
      }

      function hexToRgb(hex) {
        const v = hex.replace("#", "");
        return {
          r: parseInt(v.substring(0, 2), 16),
          g: parseInt(v.substring(2, 4), 16),
          b: parseInt(v.substring(4, 6), 16),
        };
      }

      // ===== Movimiento y colisiones =====
      function tryMoveEntity(obj, nx, ny) {
        const radius = 0.2; // radio de colisión
        // comprobar 4 esquinas alrededor del círculo
        if (at(Math.floor(nx - radius), Math.floor(ny - radius)) > 0)
          return false;
        if (at(Math.floor(nx + radius), Math.floor(ny - radius)) > 0)
          return false;
        if (at(Math.floor(nx - radius), Math.floor(ny + radius)) > 0)
          return false;
        if (at(Math.floor(nx + radius), Math.floor(ny + radius)) > 0)
          return false;
        obj.x = nx;
        obj.y = ny;
        return true;
      }

      function tryMove(nx, ny) {
        return tryMoveEntity(player, nx, ny);
      }

      function update(dt) {
        if (!MAP_W || !MAP_H) return;

        weaponCooldown = Math.max(0, weaponCooldown - dt);
        weaponAnim = Math.max(0, weaponAnim - dt * 4);

        if (reloading) {
          reloadTimer -= dt;
          if (reloadTimer <= 0) {
            const w = weapons[currentWeapon];
            const need = w.clipSize - w.loaded;
            const load = Math.min(need, w.ammo);
            w.loaded += load;
            w.ammo -= load;
            reloading = false;
          }
        } else if (shooting && weaponCooldown <= 0) {
          shoot();
        }

        const forward =
          keys.has("KeyW") || keys.has("ArrowUp")
            ? 1
            : keys.has("KeyS") || keys.has("ArrowDown")
            ? -1
            : 0;
        const strafe =
          keys.has("KeyD") || keys.has("ArrowRight")
            ? 1
            : keys.has("KeyA") || keys.has("ArrowLeft")
            ? -1
            : 0;
        const speed =
          MOVE_SPEED *
          (keys.has("ShiftLeft") || keys.has("ShiftRight") ? RUN_MULT : 1);

        const dirX = Math.cos(player.dir),
          dirY = Math.sin(player.dir);
        const moveX = (dirX * forward + -dirY * strafe) * speed * dt;
        const moveY = (dirY * forward + dirX * strafe) * speed * dt;

        // intentar mover en dos ejes para deslizar en paredes
        if (!tryMove(player.x + moveX, player.y)) {
          tryMove(player.x, player.y + moveY);
        } else {
          tryMove(player.x, player.y + moveY);
        }

        updateBullets(dt);
        updateEnemies(dt);
      }

      // ===== Minimap =====
      function drawMinimap() {
        if (!MAP_W || !MAP_H) return;
        const s = minimap.width / MAP_W;
        mctx.clearRect(0, 0, minimap.width, minimap.height);
        for (let y = 0; y < MAP_H; y++) {
          for (let x = 0; x < MAP_W; x++) {
            const v = at(x, y);
            mctx.fillStyle =
              v > 0 ? "rgba(255,255,255,.7)" : "rgba(255,255,255,.07)";
            mctx.fillRect(x * s, y * s, s, s);
          }
        }
        for (const e of enemies) {
          mctx.fillStyle = "#f00";
          mctx.beginPath();
          mctx.arc(e.x * s, e.y * s, 3, 0, Math.PI * 2);
          mctx.fill();
        }
        for (const b of bullets) {
          mctx.fillStyle = "#ff0";
          mctx.beginPath();
          mctx.arc(b.x * s, b.y * s, 2, 0, Math.PI * 2);
          mctx.fill();
        }
        // player
        mctx.fillStyle = "#00d4ff";
        mctx.beginPath();
        mctx.arc(player.x * s, player.y * s, 3, 0, Math.PI * 2);
        mctx.fill();

        // direction
        const dx = Math.cos(player.dir),
          dy = Math.sin(player.dir);
        mctx.strokeStyle = "#00d4ff";
        mctx.beginPath();
        mctx.moveTo(player.x * s, player.y * s);
        mctx.lineTo((player.x + dx * 0.8) * s, (player.y + dy * 0.8) * s);
        mctx.stroke();
      }

      // ===== Loop =====
      let last = performance.now();
      let fpsEl = document.getElementById("fps");
      let hpEl = document.getElementById("health");
      let fpsAcc = 0,
        fpsCount = 0,
        fpsDisp = 0;

      function frame(now) {
        const dt = Math.min(0.05, (now - last) / 1000); // clamp dt
        last = now;

        update(dt);
        castAndDraw();
        drawMinimap();
        drawWeaponHUD();

        // fps avg ~ each 250ms
        fpsAcc += 1 / dt;
        fpsCount++;
        if (now % 250 < 16) {
          fpsDisp = Math.round(fpsAcc / Math.max(1, fpsCount));
          fpsAcc = 0;
          fpsCount = 0;
        }
        fpsEl.textContent = `FPS: ${fpsDisp}`;
        hpEl.textContent = `Vida: ${Math.ceil(player.health)}`;

        requestAnimationFrame(frame);
      }

      requestAnimationFrame(frame);
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>DOOM-like Web Raycaster</title>
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <div id="container">
      <canvas id="game" width="800" height="600"></canvas>
      <canvas id="weaponHud" width="320" height="100"></canvas>

      <div id="hud">
        <div class="chip" id="fps">FPS: --</div>
        <div class="chip" id="health">Vida: 100</div>
        <div class="chip">
          WASD para moverte · Mouse para mirar · Shift para correr · Esc para
          pausar
        </div>
      </div>
      <canvas id="minimap" width="160" height="160"></canvas>

      <div id="help">
        <div class="chip">
          Consejo: si el mouse no gira, haz clic en "Iniciar" para activar Pointer
          Lock.
        </div>
      </div>

      <div id="overlay">
        <div class="card">
          <h2>DOOM‑like Web (Raycaster)</h2>
          <p>
            Pequeño clon estilo DOOM/Wolf3D con raycasting en Canvas 2D. No usa
            assets de DOOM: todo es generado.
          </p>
          <p>
            Controles: <strong>WASD</strong> moverse ·
            <strong>Mouse</strong> mirar · <strong>Shift</strong> correr ·
            <strong>R</strong> reiniciar · <strong>Esc</strong> liberar puntero.
          </p>
            <label>
              Mapa:
              <select id="mapSelect"></select>
            </label>
            <label>
              FOV: <span id="fovValue">90</span>°
              <input id="fovRange" type="range" min="60" max="120" value="90" />
            </label>
            <button id="startBtn">Iniciar</button>
        </div>
      </div>
    </div>

    <script type="module">
      import { fastSin, fastCos, tryMoveEntity, castRay } from "./engine.js";
      // ===== Config =====
      let FOV = Math.PI / 2; // 90° campo de visión (Quake-like)
      let baseFOV = FOV;
      const MOVE_SPEED = 3.2;
      const RUN_MULT = 1.8;
      const ROT_SPEED_MOUSE = 0.0022; // yaw
      const PITCH_SPEED_MOUSE = 0.0016; // pitch
      const PITCH_LIMIT = Math.PI / 6; // ~30°
      const HEAD_BOB_FREQ = 7.5; // Hz aprox
      const HEAD_BOB_AMP = 6; // píxeles
      const PLAYER_MAX_HEALTH = 100;

      // Colores de respaldo si no hay textura
      const WALL_COLORS = [
        "#000000",
        "#c0392b",
        "#27ae60",
        "#2980b9",
        "#8e44ad",
        "#f39c12",
      ];

        // Mapa 2D (grid de celdas). 0 = vacío; >0 = pared (tipo/color)
        let MAP_W = 0,
          MAP_H = 0;
        let MAP = new Uint8Array();
        let spawn = { x: 0, y: 0, dir: 0 };

      const TEX_SIZE = 64;
      const wallTextures = []; // por id de celda (>0)
      const weaponTexture = { img: null };

      function makeChecker(a, b) {
        const c = document.createElement("canvas");
        c.width = c.height = TEX_SIZE;
        const g = c.getContext("2d");
        for (let y = 0; y < TEX_SIZE; y++)
          for (let x = 0; x < TEX_SIZE; x++) {
            const on = (((x >> 3) + (y >> 3)) & 1) === 0;
            g.fillStyle = on ? a : b;
            g.fillRect(x, y, 1, 1);
          }
        return c;
      }

      function at(x, y) {
        if (x < 0 || y < 0 || x >= MAP_W || y >= MAP_H) return 1; // borde como pared
        return MAP[y * MAP_W + x];
      }

      // ===== Canvas setup =====
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");
      const minimap = document.getElementById("minimap");
      const mctx = minimap.getContext("2d");

      function resize() {
        canvas.width = 800;
        canvas.height = 600;
      }
      window.addEventListener("resize", resize);
      resize();

      // ===== Player =====
      const player = {
        x: 0,
        y: 0,
        dir: 0, // ángulo mirando
        velX: 0,
        velY: 0,
        health: PLAYER_MAX_HEALTH,
      };
      // ===== Weapons =====
      const weapons = [
        {
          name: "Puños",
          damage: 5,
          range: 1,
          color: "#999",
          fireDelay: 0.5,
          bulletSpeed: 15,
          clipSize: 1,
          loaded: 1,
          ammo: 0,
          reloadTime: 0,
          noAmmo: true,
        },
        {
          name: "Pistola",
          damage: 10,
          range: 6,
          color: "#ccc",
          fireDelay: 0.3,
          bulletSpeed: 25,
          clipSize: 8,
          loaded: 8,
          ammo: 24,
          reloadTime: 1.2,
        },
        {
          name: "Escopeta",
          damage: 25,
          range: 5,
          color: "#b5651d",
          fireDelay: 1.0,
          bulletSpeed: 20,
          clipSize: 2,
          loaded: 2,
          ammo: 18,
          reloadTime: 1.5,
        },
        {
          name: "Sniper",
          damage: 50,
          range: 20,
          color: "#3af",
          fireDelay: 1.5,
          bulletSpeed: 40,
          clipSize: 1,
          loaded: 1,
          ammo: 4,
          reloadTime: 2.0,
          zoomFOV: Math.PI / 8,
        },
      ];
      let currentWeapon = 0;
      let zoomed = false;
      let weaponCooldown = 0;
      let bullets = [];
      let enemies = [];
      let shooting = false;
      let reloading = false;
      let reloadTimer = 0;
      let weaponAnim = 0;

      function equipWeapon(i) {
        currentWeapon = i;
        zoomed = false;
        FOV = baseFOV;
        reloading = false;
        weaponCooldown = 0;
        weaponAnim = 0;
        shooting = false;
      }

      const weaponCanvas = document.getElementById("weaponHud");
      const wctx = weaponCanvas.getContext("2d");

      function drawWeaponHUD() {
        const w = weaponCanvas.width,
          h = weaponCanvas.height;
        wctx.clearRect(0, 0, w, h);
        wctx.fillStyle = "rgba(0,0,0,0.5)";
        wctx.fillRect(0, 0, w, h);
        const weapon = weapons[currentWeapon];
        const offset = Math.sin(weaponAnim * Math.PI) * 20;
        wctx.fillStyle = weapon.color;
        wctx.fillRect(w / 2 - 40, h - 80 + offset, 80, 80);
        wctx.fillStyle = "#fff";
        wctx.textAlign = "center";
        wctx.font = "14px sans-serif";
        wctx.fillText(weapon.name, w / 2, 20);
        if (!weapon.noAmmo)
          wctx.fillText(`${weapon.loaded}/${weapon.ammo}`, w / 2, 40);
      }

      drawWeaponHUD();

      function startReload() {
        const w = weapons[currentWeapon];
        if (w.noAmmo || reloading || w.loaded >= w.clipSize || w.ammo <= 0)
          return;
        reloading = true;
        reloadTimer = w.reloadTime;
        weaponAnim = 1;
      }

      function shoot() {
        const w = weapons[currentWeapon];
        if (!w.noAmmo) {
          if (w.loaded <= 0) {
            startReload();
            return;
          }
          w.loaded--;
        }
        weaponCooldown = w.fireDelay;
        weaponAnim = 1;
        bullets.push({
          x: player.x,
          y: player.y,
          dir: player.dir,
          speed: w.bulletSpeed,
          damage: w.damage,
          range: w.range,
          traveled: 0,
        });
      }

      function updateBullets(dt) {
        for (let i = bullets.length - 1; i >= 0; i--) {
          const b = bullets[i];
          const nx = b.x + fastCos(b.dir) * b.speed * dt;
          const ny = b.y + fastSin(b.dir) * b.speed * dt;
          const dist = Math.hypot(nx - b.x, ny - b.y);
          b.traveled += dist;
          if (at(Math.floor(nx), Math.floor(ny)) > 0 || b.traveled > b.range) {
            bullets.splice(i, 1);
            continue;
          }
          b.x = nx;
          b.y = ny;
          for (const e of enemies) {
            if (Math.hypot(e.x - b.x, e.y - b.y) < 0.3) {
              e.health -= b.damage;
              bullets.splice(i, 1);
              break;
            }
          }
        }
      }

      function updateEnemies(dt) {
        for (const e of enemies) {
          const dx = player.x - e.x;
          const dy = player.y - e.y;
          const dist = Math.hypot(dx, dy);
          if (dist < 0.5) {
            player.health = Math.max(0, player.health - 20 * dt);
          } else if (dist < 6) {
            const nx = e.x + (dx / dist) * e.speed * dt;
            const ny = e.y + (dy / dist) * e.speed * dt;
            tryMoveEntity(MAP, MAP_W, MAP_H, e, nx, ny);
          }
        }
        enemies = enemies.filter((e) => e.health > 0);
      }

      // ===== Input =====
      const keys = new Set();
      window.addEventListener("keydown", (e) => {
        keys.add(e.code);
        if (e.code === "KeyR") startReload();
        if (e.code === "Digit0") equipWeapon(0);
        if (e.code === "Digit1") equipWeapon(1);
        if (e.code === "Digit2") equipWeapon(2);
        if (e.code === "Digit3") equipWeapon(3);
      });
      window.addEventListener("keyup", (e) => keys.delete(e.code));

      window.addEventListener("wheel", (e) => {
        equipWeapon(
          (currentWeapon + (e.deltaY > 0 ? 1 : -1) + weapons.length) %
            weapons.length
        );
      });

      // Pointer lock para mirar con mouse
      const overlay = document.getElementById("overlay");
      const startBtn = document.getElementById("startBtn");
      const fovRange = document.getElementById("fovRange");
      const fovValue = document.getElementById("fovValue");
      const mapSelect = document.getElementById("mapSelect");

      async function loadMapList() {
        try {
          const res = await fetch("maps/index.json");
          const data = await res.json();
          data.maps.forEach((m) => {
            const opt = document.createElement("option");
            opt.value = m.file;
            opt.textContent = m.name;
            mapSelect.appendChild(opt);
          });
        } catch (e) {
          console.error("No se pudieron cargar los mapas", e);
        }
      }
      loadMapList();

      async function loadMap(path) {
        const res = await fetch(path);
        const data = await res.json();
        if (data.layers) {
          const layer = data.layers.find((l) => l.type === "tilelayer");
          MAP_W = data.width;
          MAP_H = data.height;
          MAP = Uint8Array.from(layer.data);
          spawn = data.player || { x: 1.5, y: 1.5, dir: 0 };
        } else {
          MAP_W = data.width;
          MAP_H = data.height;
          MAP = Uint8Array.from(data.grid);
          spawn = data.player;
        }
      }

      startBtn.addEventListener("click", async () => {
        try {
          await loadMap(`maps/${mapSelect.value}`);
          resetPlayer();
          spawnEnemies();
          canvas.requestPointerLock();
        } catch (e) {
          console.error("Error al cargar el mapa", e);
        }
      });
      document.addEventListener("pointerlockchange", () => {
        const locked = document.pointerLockElement === canvas;
        overlay.classList.toggle("hidden", locked);
      });
      fovRange.addEventListener("input", () => {
        baseFOV = (fovRange.value * Math.PI) / 180;
        if (!zoomed) FOV = baseFOV;
        fovValue.textContent = fovRange.value;
      });
      window.addEventListener("mousedown", (e) => {
        if (e.button === 0) shooting = true;
        if (currentWeapon === 3 && e.button === 2) {
          zoomed = true;
          FOV = weapons[3].zoomFOV;
        }
      });
      window.addEventListener("mouseup", (e) => {
        if (e.button === 0) shooting = false;
        if (e.button === 2 && zoomed) {
          zoomed = false;
          FOV = baseFOV;
        }
      });
      window.addEventListener("contextmenu", (e) => e.preventDefault());
      window.addEventListener("mousemove", (e) => {
        if (document.pointerLockElement === canvas) {
          player.dir += e.movementX * ROT_SPEED_MOUSE;
        }
      });

      function resetPlayer() {
        player.x = spawn.x;
        player.y = spawn.y;
        player.dir = spawn.dir;
        player.health = PLAYER_MAX_HEALTH;
      }

      function spawnEnemies() {
        enemies = [];
        const count = Math.max(5, Math.floor((MAP_W * MAP_H) / 64));
        let tries = 0;
        while (enemies.length < count && tries < count * 20) {
          const x = Math.random() * MAP_W;
          const y = Math.random() * MAP_H;
          if (
            at(Math.floor(x), Math.floor(y)) === 0 &&
            Math.hypot(x - spawn.x, y - spawn.y) > 3
          ) {
            enemies.push({ x, y, health: 30, speed: 1.2 });
          }
          tries++;
        }
      }

      // ===== Raycasting =====
      function castAndDraw() {
        if (!MAP_W || !MAP_H) return;
        const w = canvas.width,
          h = canvas.height;
        const depthBuffer = new Array(w);

        // cielo y piso
        const skyGrad = ctx.createLinearGradient(0, 0, 0, h / 2);
        skyGrad.addColorStop(0, "#1a1f2e");
        skyGrad.addColorStop(1, "#2b3a55");
        ctx.fillStyle = skyGrad;
        ctx.fillRect(0, 0, w, h / 2);
        const floorGrad = ctx.createLinearGradient(0, h / 2, 0, h);
        floorGrad.addColorStop(0, "#2b2b2b");
        floorGrad.addColorStop(1, "#0e0e0e");
        ctx.fillStyle = floorGrad;
        ctx.fillRect(0, h / 2, w, h / 2);

        // parámetros de cámara
        const dirX = fastCos(player.dir),
          dirY = fastSin(player.dir);
        const planeMag = Math.tan(FOV / 2);
        const planeX = -dirY * planeMag;
        const planeY = dirX * planeMag;

        // ray per column
        for (let x = 0; x < w; x++) {
          const cameraX = (2 * x) / w - 1; // -1..1
          const rayDirX = dirX + planeX * cameraX;
          const rayDirY = dirY + planeY * cameraX;

          const ray = castRay(MAP, MAP_W, MAP_H, player.x, player.y, rayDirX, rayDirY);
          const perpWallDist = ray.dist;
          const texId = ray.texId;
          const side = ray.side;

          // altura de la línea
          const lineHeight = Math.max(1, Math.floor(h / perpWallDist));
          let drawStart = -lineHeight / 2 + h / 2;
          if (drawStart < 0) drawStart = 0;
          let drawEnd = lineHeight / 2 + h / 2;
          if (drawEnd >= h) drawEnd = h - 1;

          // color y sombreado
          const base = WALL_COLORS[texId % WALL_COLORS.length] || "#aaa";
          // convertir hex a rgb
          const rgb = hexToRgb(base);
          const shade = 1 / (1 + perpWallDist * perpWallDist * 0.15);
          const dim = side ? 0.85 : 1.0; // lado Y un poco más oscuro
          const r = Math.min(255, Math.floor(rgb.r * shade * dim));
          const g = Math.min(255, Math.floor(rgb.g * shade * dim));
          const b = Math.min(255, Math.floor(rgb.b * shade * dim));
          ctx.fillStyle = `rgb(${r},${g},${b})`;
          ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);
          depthBuffer[x] = perpWallDist;

          // pseudo-textura: franjas sutiles
          if (((ray.mapX + ray.mapY) & 1) === 0 && x % 3 === 0) {
            ctx.fillStyle = `rgba(0,0,0,0.15)`;
            ctx.fillRect(x, drawStart, 1, drawEnd - drawStart);
          }
        }
        drawEnemies3D(depthBuffer);
      }

      function drawEnemies3D(depthBuffer) {
        const ordered = enemies
          .map((e) => ({ ...e, dist: Math.hypot(e.x - player.x, e.y - player.y) }))
          .sort((a, b) => b.dist - a.dist);
        for (const e of ordered) {
          const dx = e.x - player.x;
          const dy = e.y - player.y;
          const dist = e.dist;
          let angle = Math.atan2(dy, dx) - player.dir;
          while (angle > Math.PI) angle -= Math.PI * 2;
          while (angle < -Math.PI) angle += Math.PI * 2;
          const fov2 = FOV / 2;
          if (Math.abs(angle) > fov2) continue;
          const size = Math.min(canvas.height, (canvas.height / dist) * 0.8);
          const sx =
            canvas.width / 2 +
            (Math.tan(angle) / Math.tan(FOV / 2)) * (canvas.width / 2);
          const startX = Math.floor(sx - size / 2);
          const endX = Math.floor(sx + size / 2);
          for (let x = startX; x < endX; x++) {
            if (x < 0 || x >= depthBuffer.length) continue;
            if (dist >= depthBuffer[x]) continue;
            ctx.fillStyle = "red";
            ctx.fillRect(x, canvas.height / 2 - size / 2, 1, size);
          }
        }
      }

      function hexToRgb(hex) {
        const v = hex.replace("#", "");
        return {
          r: parseInt(v.substring(0, 2), 16),
          g: parseInt(v.substring(2, 4), 16),
          b: parseInt(v.substring(4, 6), 16),
        };
      }

      // ===== Movimiento y colisiones =====
      function tryMove(nx, ny) {
        return tryMoveEntity(MAP, MAP_W, MAP_H, player, nx, ny);
      }

      function update(dt) {
        if (!MAP_W || !MAP_H) return;

        weaponCooldown = Math.max(0, weaponCooldown - dt);
        weaponAnim = Math.max(0, weaponAnim - dt * 4);

        if (reloading) {
          reloadTimer -= dt;
          if (reloadTimer <= 0) {
            const w = weapons[currentWeapon];
            const need = w.clipSize - w.loaded;
            const load = Math.min(need, w.ammo);
            w.loaded += load;
            w.ammo -= load;
            reloading = false;
          }
        } else if (shooting && weaponCooldown <= 0) {
          shoot();
        }

        const forward =
          keys.has("KeyW") || keys.has("ArrowUp")
            ? 1
            : keys.has("KeyS") || keys.has("ArrowDown")
            ? -1
            : 0;
        const strafe =
          keys.has("KeyD") || keys.has("ArrowRight")
            ? 1
            : keys.has("KeyA") || keys.has("ArrowLeft")
            ? -1
            : 0;
        const speed =
          MOVE_SPEED *
          (keys.has("ShiftLeft") || keys.has("ShiftRight") ? RUN_MULT : 1);

        const dirX = fastCos(player.dir),
          dirY = fastSin(player.dir);
        const moveX = (dirX * forward + -dirY * strafe) * speed * dt;
        const moveY = (dirY * forward + dirX * strafe) * speed * dt;

        // intentar mover en dos ejes para deslizar en paredes
        tryMove(player.x + moveX, player.y);
        tryMove(player.x, player.y + moveY);

        updateBullets(dt);
        updateEnemies(dt);
      }

      // ===== Minimap =====
      function drawMinimap() {
        if (!MAP_W || !MAP_H) return;
        const s = minimap.width / MAP_W;
        mctx.clearRect(0, 0, minimap.width, minimap.height);
        for (let y = 0; y < MAP_H; y++) {
          for (let x = 0; x < MAP_W; x++) {
            const v = at(x, y);
            mctx.fillStyle =
              v > 0 ? "rgba(255,255,255,.7)" : "rgba(255,255,255,.07)";
            mctx.fillRect(x * s, y * s, s, s);
          }
        }
        for (const e of enemies) {
          mctx.fillStyle = "#f00";
          mctx.beginPath();
          mctx.arc(e.x * s, e.y * s, 3, 0, Math.PI * 2);
          mctx.fill();
        }
        for (const b of bullets) {
          mctx.fillStyle = "#ff0";
          mctx.beginPath();
          mctx.arc(b.x * s, b.y * s, 2, 0, Math.PI * 2);
          mctx.fill();
        }
        // player
        mctx.fillStyle = "#00d4ff";
        mctx.beginPath();
        mctx.arc(player.x * s, player.y * s, 3, 0, Math.PI * 2);
        mctx.fill();

        // direction
        const dx = fastCos(player.dir),
          dy = fastSin(player.dir);
        mctx.strokeStyle = "#00d4ff";
        mctx.beginPath();
        mctx.moveTo(player.x * s, player.y * s);
        mctx.lineTo((player.x + dx * 0.8) * s, (player.y + dy * 0.8) * s);
        mctx.stroke();
      }

      // ===== Loop =====
      let last = performance.now();
      let fpsEl = document.getElementById("fps");
      let hpEl = document.getElementById("health");
      let fpsAcc = 0,
        fpsCount = 0,
        fpsDisp = 0;

      function frame(now) {
        const dt = Math.min(0.05, (now - last) / 1000); // clamp dt
        last = now;

        update(dt);
        castAndDraw();
        drawMinimap();
        drawWeaponHUD();

        // fps avg ~ each 250ms
        fpsAcc += 1 / dt;
        fpsCount++;
        if (now % 250 < 16) {
          fpsDisp = Math.round(fpsAcc / Math.max(1, fpsCount));
          fpsAcc = 0;
          fpsCount = 0;
        }
        fpsEl.textContent = `FPS: ${fpsDisp}`;
        hpEl.textContent = `Vida: ${Math.ceil(player.health)}`;

        requestAnimationFrame(frame);
      }

      requestAnimationFrame(frame);
    </script>
  </body>
</html>
